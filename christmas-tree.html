<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Gesture Controlled Christmas Tree | Sen's World</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: #000300;
            font-family: 'Merriweather', serif;
            color: #FFD700;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        #video-input {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            z-index: 2;
            border-radius: 8px;
            opacity: 0;
            transform: scaleX(-1);
            border: 2px solid rgba(255, 215, 0, 0.5);
            pointer-events: none;
        }
        
        #debug-canvas {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            z-index: 3;
            border-radius: 8px;
            opacity: 0;
            transform: scaleX(-1);
            pointer-events: none;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 28px;
            z-index: 10;
            letter-spacing: 4px;
            text-transform: uppercase;
            pointer-events: none;
            transition: opacity 0.5s;
            font-family: 'Playfair Display', serif;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: rgba(255, 215, 0, 0.4);
            font-size: 10px;
            font-family: 'Playfair Display', serif;
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
            letter-spacing: 2px;
        }
        
        #ui-stats {
            position: absolute;
            bottom: 30px;
            left: 40px;
            color: #888;
            z-index: 10;
            font-family: sans-serif;
            user-select: none;
        }
        
        .stat-item {
            margin-bottom: 15px;
        }
        
        .stat-label {
            font-size: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 24px;
            color: #FFD700;
            font-weight: bold;
            margin: 0;
        }
        
        .stat-unit {
            font-size: 10px;
            color: #555;
            font-weight: normal;
        }
        
        #ui-buttons {
            position: absolute;
            bottom: 30px;
            right: 40px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }
        
        .ui-button {
            padding: 12px 15px;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #FFD700;
            font-family: sans-serif;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: all 0.3s;
        }
        
        .ui-button:hover {
            background: rgba(255, 215, 0, 0.2);
        }
        
        .ui-button.active {
            background: #FFD700;
            color: #000;
        }
        
        .ui-button.large {
            padding: 12px 30px;
            font-family: serif;
            font-size: 14px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        window.THREE = THREE;
        window.EffectComposer = EffectComposer;
        window.RenderPass = RenderPass;
        window.UnrealBloomPass = UnrealBloomPass;
        window.threeLoaded = true;
        if (window.onThreeLoaded) window.onThreeLoaded();
    </script>
    <script>
        const threeUMDScript = document.createElement('script');
        threeUMDScript.src = 'https://unpkg.com/three@0.160.0/build/three.min.js';
        threeUMDScript.onload = () => {
            const postProcessingScripts = [
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/EffectComposer.js',
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/RenderPass.js',
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js'
            ];
            let loadedCount = 0;
            postProcessingScripts.forEach((src) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => {
                    loadedCount++;
                    if (loadedCount === postProcessingScripts.length && !window.threeLoaded && window.THREE) {
                        window.threeLoaded = true;
                        window.threeUMD = true;
                        if (window.onThreeLoaded) window.onThreeLoaded();
                    }
                };
                document.head.appendChild(script);
            });
        };
        document.head.appendChild(threeUMDScript);
        
        setTimeout(() => {
            if (!window.threeLoaded && window.THREE) {
                window.threeLoaded = true;
                window.threeUMD = true;
                if (window.onThreeLoaded) window.onThreeLoaded();
            }
        }, 3000);
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"></script>
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "rhkatcquvv");
    </script>
</head>
<body>
    <div id="loading">System Initializing...</div>
    <div id="status">INITIALIZING...</div>
    <video id="video-input" playsinline muted autoplay></video>
    <canvas id="debug-canvas"></canvas>
    <div id="canvas-container"></div>
    
    <div id="ui-stats">
        <div class="stat-item">
            <p class="stat-label">Memories</p>
            <p class="stat-value">300 <span class="stat-unit">TEXT CLOUDS</span></p>
        </div>
        <div class="stat-item">
            <p class="stat-label">Foliage</p>
            <p class="stat-value">15K <span class="stat-unit">EMERALD NEEDLES</span></p>
        </div>
    </div>
    
    <div id="ui-buttons">
        <button class="ui-button" id="debug-btn">üõ† DEBUG</button>
        <button class="ui-button large" id="toggle-btn">Disperse</button>
    </div>

<script>
    /**
     * ÈÖçÁΩÆÂèÇÊï∞
     */
    const CONFIG = {
        colors: {
            emerald: '#004225',
            gold: '#FFD700',
            silver: '#ECEFF1',
            red: '#D32F2F',
            green: '#2E7D32',
            white: '#FFFFFF',
            warmLight: '#FFD54F',
            lights: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'],
            giftColors: ['#D32F2F', '#FFD700', '#1976D2', '#2E7D32'],
            candyColors: ['#FF0000', '#FFFFFF']
        },
        counts: {
            foliage: 15000,
            textOrnaments: 300,  // ÊñáÂ≠óË£ÖÈ•∞Êï∞ÈáèÔºàÊõøÊç¢ÁÖßÁâáÔºâ
            elements: 200,
            lights: 400
        },
        tree: {
            height: 22,
            radius: 9
        }
    };

    /**
     * ÂÖ®Â±ÄÂèòÈáè
     */
    let scene, camera, renderer, composer;
    let foliagePoints, textOrnamentsGroup, elementsGroup, lightsGroup, topStar;
    let sceneState = 'CHAOS'; // 'CHAOS' or 'FORMED'
    let rotationSpeed = 0;
    let gestureRecognizer = null;
    let debugMode = false;
    let videoElement, debugCanvas, debugCtx;

    /**
     * Ëé∑ÂèñÊñáÂ≠óÂùêÊ†áÔºàÁîüÊàê"ÂÜØÁ¶æÂ≠êÊ∂µ"ÊñáÂ≠óÁ≤íÂ≠êÔºâ
     */
    function getTextCoordinates(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const width = 800;
        const height = 300;
        canvas.width = width;
        canvas.height = height;
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);
        
        ctx.font = 'bold 120px "Microsoft YaHei", "SimHei", sans-serif';
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, width / 2, height / 2);

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const coords = [];
        
        const step = 2;
        for(let y = 0; y < height; y += step) {
            for(let x = 0; x < width; x += step) {
                const index = (y * width + x) * 4;
                if(data[index] > 128) {
                    coords.push({x: x - width/2, y: y - height/2});
                }
            }
        }
        return coords;
    }

    /**
     * ÂàùÂßãÂåñÂú∫ÊôØ
     */
    function init() {
        const container = document.getElementById('canvas-container');
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color('#000300');

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 60);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // ÁéØÂ¢ÉÂÖâ
        const ambientLight = new THREE.AmbientLight('#003311', 0.4);
        scene.add(ambientLight);

        // ÁÇπÂÖâÊ∫ê
        const pointLight1 = new THREE.PointLight(CONFIG.colors.warmLight, 100);
        pointLight1.position.set(30, 30, 30);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(CONFIG.colors.gold, 50);
        pointLight2.position.set(-30, 10, -30);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight('#ffffff', 30);
        pointLight3.position.set(0, -20, 10);
        scene.add(pointLight3);

        // ÂàõÂª∫Á≤íÂ≠êÁ≥ªÁªü
        createFoliage();
        createTextOrnaments();
        createElements();
        createLights();
        createTopStar();

        // ÂêéÂ§ÑÁêÜ
        setupPostProcessing();

        window.addEventListener('resize', onWindowResize);
    }

    /**
     * ÂàõÂª∫Ê†ëÂè∂Á≤íÂ≠ê
     */
    function createFoliage() {
        const count = CONFIG.counts.foliage;
        const positions = new Float32Array(count * 3);
        const targetPositions = new Float32Array(count * 3);
        const randoms = new Float32Array(count);
        const colors = new Float32Array(count * 3);

        // ÂàùÂßã‰ΩçÁΩÆÔºöÁêÉ‰ΩìÂÜÖÈöèÊú∫
        for (let i = 0; i < count; i++) {
            const radius = 25;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            positions[i*3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = radius * Math.cos(phi);

            // ÁõÆÊ†á‰ΩçÁΩÆÔºöÂú£ËØûÊ†ëÂΩ¢Áä∂
            const h = CONFIG.tree.height;
            const y = (Math.random() * h) - (h / 2);
            const normalizedY = (y + (h/2)) / h;
            const rBase = CONFIG.tree.radius;
            const currentRadius = rBase * (1 - normalizedY);
            const theta2 = Math.random() * Math.PI * 2;
            const r = Math.random() * currentRadius;
            
            targetPositions[i*3] = r * Math.cos(theta2);
            targetPositions[i*3+1] = y;
            targetPositions[i*3+2] = r * Math.sin(theta2);

            randoms[i] = Math.random();
            
            const color = new THREE.Color(CONFIG.colors.emerald);
            colors[i*3] = color.r;
            colors[i*3+1] = color.g;
            colors[i*3+2] = color.b;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
        geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uProgress: { value: 0 },
                uColor: { value: new THREE.Color(CONFIG.colors.emerald) }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uProgress;
                attribute vec3 targetPosition;
                attribute float random;
                varying vec2 vUv;
                varying float vMix;
                
                float cubicInOut(float t) {
                    return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;
                }
                
                void main() {
                    vUv = uv;
                    vec3 noise = vec3(sin(uTime * 1.5 + position.x), cos(uTime + position.y), sin(uTime * 1.5 + position.z)) * 0.15;
                    float t = cubicInOut(uProgress);
                    vec3 finalPos = mix(position, targetPosition + noise, t);
                    vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                    gl_PointSize = (60.0 * (1.0 + random)) / -mvPosition.z;
                    gl_Position = projectionMatrix * mvPosition;
                    vMix = t;
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying float vMix;
                
                void main() {
                    float r = distance(gl_PointCoord, vec2(0.5));
                    if (r > 0.5) discard;
                    vec3 finalColor = mix(uColor * 0.3, uColor * 1.2, vMix);
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        foliagePoints = new THREE.Points(geometry, material);
        foliagePoints.position.y = -6;
        scene.add(foliagePoints);
    }

    /**
     * ÂàõÂª∫ÊñáÂ≠óË£ÖÈ•∞ÔºàÊõøÊç¢ÁÖßÁâáÔºâ
     */
    function createTextOrnaments() {
        textOrnamentsGroup = new THREE.Group();
        const count = CONFIG.counts.textOrnaments;
        
        // ÁîüÊàê"ÂÜØÁ¶æÂ≠êÊ∂µ"ÊñáÂ≠óÂùêÊ†á
        const textCoords = getTextCoordinates("ÂÜØÁ¶æÂ≠êÊ∂µ");
        
        // ‰∏∫ÊØè‰∏™Ë£ÖÈ•∞ÂàõÂª∫ÊñáÂ≠óÁ≤íÂ≠êÁªÑ
        for (let i = 0; i < count; i++) {
            const group = new THREE.Group();
            
            // ‰ªéÊñáÂ≠óÂùêÊ†á‰∏≠ÈöèÊú∫ÈÄâÊã©‰∏Ä‰∫õÁÇπÊù•ÁªÑÊàêÊñáÂ≠ó
            const textPoints = [];
            const numPoints = Math.min(50, textCoords.length);
            const startIdx = (i * numPoints) % textCoords.length;
            
            for (let j = 0; j < numPoints; j++) {
                const idx = (startIdx + j) % textCoords.length;
                textPoints.push(textCoords[idx]);
            }
            
            // ÂàõÂª∫ÊñáÂ≠óÁ≤íÂ≠ê
            const positions = new Float32Array(textPoints.length * 3);
            const colors = new Float32Array(textPoints.length * 3);
            const goldColor = new THREE.Color(CONFIG.colors.gold);
            
            textPoints.forEach((point, idx) => {
                positions[idx*3] = point.x * 0.01;
                positions[idx*3+1] = point.y * 0.01;
                positions[idx*3+2] = 0;
                
                colors[idx*3] = goldColor.r;
                colors[idx*3+1] = goldColor.g;
                colors[idx*3+2] = goldColor.b;
            });
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                emissive: CONFIG.colors.gold,
                emissiveIntensity: 1.0
            });
            
            const points = new THREE.Points(geometry, material);
            group.add(points);
            
            // Ê∑ªÂä†ËæπÊ°ÜÔºàÊãçÁ´ãÂæóÈ£éÊ†ºÔºâ
            const borderColors = ['#FFFAF0', '#F0E68C', '#E6E6FA', '#FFB6C1', '#98FB98', '#87CEFA', '#FFDAB9'];
            const borderGeometry = new THREE.PlaneGeometry(1.2, 1.5);
            const borderMaterial = new THREE.MeshStandardMaterial({
                color: borderColors[Math.floor(Math.random() * borderColors.length)],
                roughness: 0.9,
                metalness: 0
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.z = -0.01;
            group.add(border);
            
            // ÂàùÂßã‰ΩçÁΩÆÂíåÁõÆÊ†á‰ΩçÁΩÆ
            const chaosPos = new THREE.Vector3(
                (Math.random() - 0.5) * 70,
                (Math.random() - 0.5) * 70,
                (Math.random() - 0.5) * 70
            );
            
            const h = CONFIG.tree.height;
            const y = (Math.random() * h) - (h / 2);
            const rBase = CONFIG.tree.radius;
            const currentRadius = (rBase * (1 - (y + (h/2)) / h)) + 0.5;
            const theta = Math.random() * Math.PI * 2;
            const targetPos = new THREE.Vector3(
                currentRadius * Math.cos(theta),
                y,
                currentRadius * Math.sin(theta)
            );
            
            group.userData.chaosPos = chaosPos;
            group.userData.targetPos = targetPos;
            group.userData.currentPos = chaosPos.clone();
            group.userData.rotationSpeed = {
                x: (Math.random() - 0.5) * 1.0,
                y: (Math.random() - 0.5) * 1.0,
                z: (Math.random() - 0.5) * 1.0
            };
            group.userData.wobbleOffset = Math.random() * 10;
            group.userData.wobbleSpeed = 0.5 + Math.random() * 0.5;
            
            const scale = 0.8 + Math.random() * 0.6;
            group.scale.set(scale, scale, scale);
            
            group.position.copy(chaosPos);
            textOrnamentsGroup.add(group);
        }
        
        textOrnamentsGroup.position.y = -6;
        scene.add(textOrnamentsGroup);
    }

    /**
     * ÂàõÂª∫Âú£ËØûÂÖÉÁ¥†
     */
    function createElements() {
        elementsGroup = new THREE.Group();
        const count = CONFIG.counts.elements;
        
        const boxGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const caneGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.2, 8);
        
        for (let i = 0; i < count; i++) {
            const type = Math.floor(Math.random() * 3);
            let geometry, color, scale;
            
            if (type === 0) {
                geometry = boxGeometry;
                color = CONFIG.colors.giftColors[Math.floor(Math.random() * CONFIG.colors.giftColors.length)];
                scale = 0.8 + Math.random() * 0.4;
            } else if (type === 1) {
                geometry = sphereGeometry;
                color = CONFIG.colors.giftColors[Math.floor(Math.random() * CONFIG.colors.giftColors.length)];
                scale = 0.6 + Math.random() * 0.4;
            } else {
                geometry = caneGeometry;
                color = Math.random() > 0.5 ? CONFIG.colors.red : CONFIG.colors.white;
                scale = 0.7 + Math.random() * 0.3;
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.4,
                emissive: color,
                emissiveIntensity: 0.2
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.scale.set(scale, scale, scale);
            
            const chaosPos = new THREE.Vector3(
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60
            );
            
            const h = CONFIG.tree.height;
            const y = (Math.random() * h) - (h / 2);
            const rBase = CONFIG.tree.radius;
            const currentRadius = (rBase * (1 - (y + (h/2)) / h)) * 0.95;
            const theta = Math.random() * Math.PI * 2;
            const targetPos = new THREE.Vector3(
                currentRadius * Math.cos(theta),
                y,
                currentRadius * Math.sin(theta)
            );
            
            mesh.userData.chaosPos = chaosPos;
            mesh.userData.targetPos = targetPos;
            mesh.userData.currentPos = chaosPos.clone();
            mesh.userData.rotationSpeed = {
                x: (Math.random() - 0.5) * 2.0,
                y: (Math.random() - 0.5) * 2.0,
                z: (Math.random() - 0.5) * 2.0
            };
            
            mesh.position.copy(chaosPos);
            elementsGroup.add(mesh);
        }
        
        elementsGroup.position.y = -6;
        scene.add(elementsGroup);
    }

    /**
     * ÂàõÂª∫ÂΩ©ÁÅØ
     */
    function createLights() {
        lightsGroup = new THREE.Group();
        const count = CONFIG.counts.lights;
        const geometry = new THREE.SphereGeometry(0.8, 8, 8);
        
        for (let i = 0; i < count; i++) {
            const color = CONFIG.colors.lights[Math.floor(Math.random() * CONFIG.colors.lights.length)];
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0,
                toneMapped: false
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.scale.set(0.15, 0.15, 0.15);
            
            const chaosPos = new THREE.Vector3(
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60
            );
            
            const h = CONFIG.tree.height;
            const y = (Math.random() * h) - (h / 2);
            const rBase = CONFIG.tree.radius;
            const currentRadius = (rBase * (1 - (y + (h/2)) / h)) + 0.3;
            const theta = Math.random() * Math.PI * 2;
            const targetPos = new THREE.Vector3(
                currentRadius * Math.cos(theta),
                y,
                currentRadius * Math.sin(theta)
            );
            
            mesh.userData.chaosPos = chaosPos;
            mesh.userData.targetPos = targetPos;
            mesh.userData.currentPos = chaosPos.clone();
            mesh.userData.speed = 2 + Math.random() * 3;
            mesh.userData.timeOffset = Math.random() * 100;
            
            mesh.position.copy(chaosPos);
            lightsGroup.add(mesh);
        }
        
        lightsGroup.position.y = -6;
        scene.add(lightsGroup);
    }

    /**
     * ÂàõÂª∫È°∂ÈÉ®ÊòüÊòü
     */
    function createTopStar() {
        const starShape = new THREE.Shape();
        const outerRadius = 1.3;
        const innerRadius = 0.7;
        const points = 5;
        
        for (let i = 0; i < points * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
            if (i === 0) {
                starShape.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
            } else {
                starShape.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
            }
        }
        starShape.closePath();
        
        const starGeometry = new THREE.ExtrudeGeometry(starShape, {
            depth: 0.4,
            bevelEnabled: true,
            bevelThickness: 0.1,
            bevelSize: 0.1,
            bevelSegments: 3
        });
        
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.gold,
            emissive: CONFIG.colors.gold,
            emissiveIntensity: 1.5,
            roughness: 0.1,
            metalness: 1.0
        });
        
        const star = new THREE.Mesh(starGeometry, goldMaterial);
        star.position.set(0, CONFIG.tree.height / 2 + 1.8, 0);
        
        topStar = new THREE.Group();
        topStar.add(star);
        topStar.position.y = -6;
        scene.add(topStar);
    }

    /**
     * ËÆæÁΩÆÂêéÂ§ÑÁêÜ
     */
    function setupPostProcessing() {
        try {
            const RenderPassClass = window.RenderPass || (typeof RenderPass !== 'undefined' ? RenderPass : null);
            const UnrealBloomPassClass = window.UnrealBloomPass || (typeof UnrealBloomPass !== 'undefined' ? UnrealBloomPass : null);
            const EffectComposerClass = window.EffectComposer || (typeof EffectComposer !== 'undefined' ? EffectComposer : null);
            
            if (!RenderPassClass && window.THREE && window.THREE.RenderPass) {
                RenderPassClass = window.THREE.RenderPass;
                UnrealBloomPassClass = window.THREE.UnrealBloomPass;
                EffectComposerClass = window.THREE.EffectComposer;
            }
            
            if (RenderPassClass && UnrealBloomPassClass && EffectComposerClass) {
                const renderScene = new RenderPassClass(scene, camera);
                const bloomPass = new UnrealBloomPassClass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, 0.4, 0.85
                );
                bloomPass.strength = 1.5;
                bloomPass.radius = 0.5;
                bloomPass.threshold = 0.8;

                composer = new EffectComposerClass(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            }
        } catch (error) {
            console.warn('ÂêéÂ§ÑÁêÜÊïàÊûúÂàùÂßãÂåñÂ§±Ë¥•:', error);
            composer = null;
        }
    }

    /**
     * ÂàùÂßãÂåñÊâãÂäøËØÜÂà´
     */
    async function initGestureRecognition() {
        try {
            updateStatus("DOWNLOADING AI...");
            
            const { GestureRecognizer, FilesetResolver, DrawingUtils } = window;
            if (!GestureRecognizer || !FilesetResolver) {
                throw new Error('MediaPipe not loaded');
            }
            
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            updateStatus("REQUESTING CAMERA...");
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;
                videoElement.play();
                updateStatus("AI READY: SHOW HAND");
                predictWebcam();
            } else {
                updateStatus("ERROR: CAMERA PERMISSION DENIED");
            }
        } catch (err) {
            updateStatus(`ERROR: ${err.message || 'MODEL FAILED'}`);
            console.error('Gesture recognition error:', err);
        }
    }

    /**
     * È¢ÑÊµãÊâãÂäø
     */
    function predictWebcam() {
        if (!gestureRecognizer || !videoElement || videoElement.videoWidth === 0) {
            requestAnimationFrame(predictWebcam);
            return;
        }
        
        const results = gestureRecognizer.recognizeForVideo(videoElement, Date.now());
        
        // Ë∞ÉËØïÁîªÂ∏É
        if (debugMode && debugCanvas && debugCtx) {
            debugCanvas.width = videoElement.videoWidth;
            debugCanvas.height = videoElement.videoHeight;
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            
            if (results.landmarks) {
                const drawingUtils = new window.DrawingUtils(debugCtx);
                for (const landmarks of results.landmarks) {
                    drawingUtils.drawConnectors(landmarks, window.GestureRecognizer.HAND_CONNECTIONS, { color: "#FFD700", lineWidth: 2 });
                    drawingUtils.drawLandmarks(landmarks, { color: "#FF0000", lineWidth: 1 });
                }
            }
        }
        
        if (results.gestures.length > 0) {
            const name = results.gestures[0][0].categoryName;
            const score = results.gestures[0][0].score;
            
            if (score > 0.4) {
                if (name === "Open_Palm") {
                    setSceneState('CHAOS');
                } else if (name === "Closed_Fist") {
                    setSceneState('FORMED');
                }
                if (debugMode) {
                    updateStatus(`DETECTED: ${name}`);
                }
            }
            
            if (results.landmarks.length > 0) {
                const speed = (0.5 - results.landmarks[0][0].x) * 0.15;
                rotationSpeed = Math.abs(speed) > 0.01 ? speed : 0;
            }
        } else {
            rotationSpeed = 0;
            if (debugMode) {
                updateStatus("AI READY: NO HAND");
            }
        }
        
        requestAnimationFrame(predictWebcam);
    }

    /**
     * ËÆæÁΩÆÂú∫ÊôØÁä∂ÊÄÅ
     */
    function setSceneState(state) {
        sceneState = state;
        const btn = document.getElementById('toggle-btn');
        if (btn) {
            btn.textContent = state === 'CHAOS' ? 'Assemble Tree' : 'Disperse';
        }
    }

    /**
     * Êõ¥Êñ∞Áä∂ÊÄÅÊòæÁ§∫
     */
    function updateStatus(text) {
        const statusEl = document.getElementById('status');
        if (statusEl) {
            statusEl.textContent = text;
            statusEl.style.color = text.includes('ERROR') ? '#FF0000' : 'rgba(255, 215, 0, 0.4)';
        }
    }

    /**
     * Á™óÂè£Â§ßÂ∞èË∞ÉÊï¥
     */
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (composer) {
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    /**
     * Âä®ÁîªÂæ™ÁéØ
     */
    function animate() {
        requestAnimationFrame(animate);
        
        const time = performance.now() * 0.001;
        const delta = 0.016; // ÂÅáËÆæ60fps
        
        // Êõ¥Êñ∞Ê†ëÂè∂Á≤íÂ≠ê
        if (foliagePoints && foliagePoints.material) {
            const material = foliagePoints.material;
            material.uniforms.uTime.value = time;
            const targetProgress = sceneState === 'FORMED' ? 1 : 0;
            material.uniforms.uProgress.value = THREE.MathUtils.damp(
                material.uniforms.uProgress.value,
                targetProgress,
                1.5,
                delta
            );
        }
        
        // Êõ¥Êñ∞ÊñáÂ≠óË£ÖÈ•∞
        if (textOrnamentsGroup) {
            textOrnamentsGroup.children.forEach((group) => {
                const target = sceneState === 'FORMED' ? group.userData.targetPos : group.userData.chaosPos;
                group.userData.currentPos.lerp(target, delta * (sceneState === 'FORMED' ? 0.8 : 0.5));
                group.position.copy(group.userData.currentPos);
                
                if (sceneState === 'FORMED') {
                    const targetLookPos = new THREE.Vector3(
                        group.position.x * 2,
                        group.position.y + 0.5,
                        group.position.z * 2
                    );
                    group.lookAt(targetLookPos);
                    
                    const wobbleX = Math.sin(time * group.userData.wobbleSpeed + group.userData.wobbleOffset) * 0.05;
                    const wobbleZ = Math.cos(time * group.userData.wobbleSpeed * 0.8 + group.userData.wobbleOffset) * 0.05;
                    group.rotation.x += wobbleX;
                    group.rotation.z += wobbleZ;
                } else {
                    group.rotation.x += delta * group.userData.rotationSpeed.x;
                    group.rotation.y += delta * group.userData.rotationSpeed.y;
                    group.rotation.z += delta * group.userData.rotationSpeed.z;
                }
            });
        }
        
        // Êõ¥Êñ∞Âú£ËØûÂÖÉÁ¥†
        if (elementsGroup) {
            elementsGroup.children.forEach((mesh) => {
                const target = sceneState === 'FORMED' ? mesh.userData.targetPos : mesh.userData.chaosPos;
                mesh.userData.currentPos.lerp(target, delta * 1.5);
                mesh.position.copy(mesh.userData.currentPos);
                mesh.rotation.x += delta * mesh.userData.rotationSpeed.x;
                mesh.rotation.y += delta * mesh.userData.rotationSpeed.y;
                mesh.rotation.z += delta * mesh.userData.rotationSpeed.z;
            });
        }
        
        // Êõ¥Êñ∞ÂΩ©ÁÅØ
        if (lightsGroup) {
            lightsGroup.children.forEach((mesh) => {
                const target = sceneState === 'FORMED' ? mesh.userData.targetPos : mesh.userData.chaosPos;
                mesh.userData.currentPos.lerp(target, delta * 2.0);
                mesh.position.copy(mesh.userData.currentPos);
                
                const intensity = (Math.sin(time * mesh.userData.speed + mesh.userData.timeOffset) + 1) / 2;
                if (mesh.material) {
                    mesh.material.emissiveIntensity = sceneState === 'FORMED' ? 3 + intensity * 4 : 0;
                }
            });
        }
        
        // Êõ¥Êñ∞È°∂ÈÉ®ÊòüÊòü
        if (topStar) {
            topStar.rotation.y += delta * 0.5;
            const targetScale = sceneState === 'FORMED' ? 1 : 0;
            topStar.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), delta * 3);
        }
        
        // Áõ∏Êú∫ÊóãËΩ¨
        if (rotationSpeed !== 0 && sceneState === 'CHAOS') {
            camera.position.x = Math.sin(time * rotationSpeed) * 60;
            camera.position.z = 60 + Math.cos(time * rotationSpeed) * 20;
            camera.lookAt(0, 0, 0);
        }
        
        // Ê∏≤Êüì
        if (composer) {
            composer.render();
        } else {
            renderer.render(scene, camera);
        }
    }

    /**
     * ‰∏ªÁ®ãÂ∫èÂÖ•Âè£
     */
    let initializationStarted = false;
    let threeReady = false;
    
    function checkAndInit() {
        if (initializationStarted) return;
        if (!threeReady) {
            console.log('Á≠âÂæÖ Three.js Âä†ËΩΩ...');
            return;
        }
        
        initializationStarted = true;
        console.log('ÂºÄÂßãÂàùÂßãÂåñÂú∫ÊôØ...');
        
        try {
            videoElement = document.getElementById('video-input');
            debugCanvas = document.getElementById('debug-canvas');
            debugCtx = debugCanvas.getContext('2d');
            
            init();
            initGestureRecognition();
            animate();
            
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
        } catch (error) {
            console.error('ÂàùÂßãÂåñÈîôËØØ:', error);
            document.getElementById('loading').textContent = 'ÂàùÂßãÂåñÂ§±Ë¥•: ' + error.message;
        }
    }
    
    function checkThreeLoaded() {
        if (window.THREE && window.THREE.Scene) {
            threeReady = true;
            console.log('Three.js Â∑≤Âä†ËΩΩ');
            checkAndInit();
            return true;
        }
        return false;
    }
    
    if (window.threeLoaded || checkThreeLoaded()) {
        threeReady = true;
        checkAndInit();
    } else {
        window.onThreeLoaded = () => {
            threeReady = true;
            console.log('Three.js Âä†ËΩΩÂÆåÊàêÔºàÈÄöËøáÂõûË∞ÉÔºâ');
            checkAndInit();
        };
        
        const checkThree = setInterval(() => {
            if (checkThreeLoaded()) {
                clearInterval(checkThree);
            }
        }, 100);
        
        setTimeout(() => {
            clearInterval(checkThree);
            if (!threeReady && window.THREE) {
                threeReady = true;
                checkAndInit();
            }
        }, 10000);
    }
    
    // UI ÊåâÈíÆ‰∫ã‰ª∂
    document.getElementById('debug-btn').addEventListener('click', () => {
        debugMode = !debugMode;
        const btn = document.getElementById('debug-btn');
        btn.textContent = debugMode ? 'HIDE DEBUG' : 'üõ† DEBUG';
        btn.classList.toggle('active', debugMode);
        if (videoElement) videoElement.style.opacity = debugMode ? '0.6' : '0';
        if (debugCanvas) debugCanvas.style.opacity = debugMode ? '1' : '0';
    });
    
    document.getElementById('toggle-btn').addEventListener('click', () => {
        setSceneState(sceneState === 'CHAOS' ? 'FORMED' : 'CHAOS');
    });
</script>
</body>
</html>

