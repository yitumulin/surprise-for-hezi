<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Gesture Controlled Christmas Tree | Sen's World</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Merriweather', 'Helvetica Neue', sans-serif; 
        }
        body.dark {
            background-color: #121212;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        #video-input { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            width: 160px; 
            height: 120px; 
            z-index: 2; 
            border-radius: 8px; 
            opacity: 0.6; 
            transform: scaleX(-1); 
            border: 1px solid rgba(255, 215, 0, 0.3); 
            transition: opacity 0.3s;
        }
        body.dark #video-input {
            border-color: rgba(243, 156, 18, 0.4);
        }
        #loading { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #FFD700; 
            font-size: 24px; 
            z-index: 10; 
            letter-spacing: 2px; 
            text-transform: uppercase; 
            pointer-events: none; 
            transition: opacity 0.5s; 
            font-family: 'Playfair Display', serif;
        }
        body.dark #loading {
            color: #f39c12;
        }
        .hidden { opacity: 0; }
    </style>
    <!-- Three.js 模块加载 -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // 将模块暴露到全局作用域
        window.THREE = THREE;
        window.EffectComposer = EffectComposer;
        window.RenderPass = RenderPass;
        window.UnrealBloomPass = UnrealBloomPass;
        
        // 标记 Three.js 已加载
        window.threeLoaded = true;
        if (window.onThreeLoaded) window.onThreeLoaded();
    </script>
    <!-- 备用方案：如果模块加载失败，使用 UMD 版本 -->
    <script>
        // 立即加载 UMD 版本作为备用（本地文件协议时 ES 模块可能失败）
        const threeUMDScript = document.createElement('script');
        threeUMDScript.src = 'https://unpkg.com/three@0.160.0/build/three.min.js';
        threeUMDScript.onload = () => {
            console.log('Three.js UMD 版本已加载（备用）');
            // 加载后处理模块的 UMD 版本
            const postProcessingScripts = [
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/EffectComposer.js',
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/RenderPass.js',
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js'
            ];
            let loadedCount = 0;
            postProcessingScripts.forEach((src, index) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => {
                    loadedCount++;
                    if (loadedCount === postProcessingScripts.length) {
                        console.log('Three.js 后处理模块已加载（UMD）');
                        // 如果 ES 模块版本未加载，使用 UMD 版本
                        if (!window.threeLoaded && window.THREE) {
                            window.threeLoaded = true;
                            window.threeUMD = true;
                            if (window.onThreeLoaded) window.onThreeLoaded();
                        }
                    }
                };
                document.head.appendChild(script);
            });
        };
        threeUMDScript.onerror = () => {
            console.error('Three.js UMD 版本加载失败');
        };
        document.head.appendChild(threeUMDScript);
        
        // 3秒后检查，如果 ES 模块未加载成功，强制使用 UMD 版本
        setTimeout(() => {
            if (!window.threeLoaded && window.THREE) {
                console.warn('ES 模块加载可能失败，使用 UMD 版本');
                window.threeLoaded = true;
                window.threeUMD = true;
                if (window.onThreeLoaded) window.onThreeLoaded();
            }
        }, 3000);
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "rhkatcquvv");
    </script>
</head>
<body>
  <script>
    (function() {
      try {
        var theme = localStorage.getItem('theme');
        var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (theme === 'dark' || (!theme && prefersDark)) {
          document.body.classList.add('dark');
        }
      } catch (e) {
        console.error('Error applying initial theme:', e);
      }
    })();
  </script>

    <div id="loading">System Initializing...</div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

<script type="x-shader/x-vertex" id="vertexshader">
    // --------------------------------------------------------
    // Vertex Shader: 处理粒子位置混合 (Morphing)
    // --------------------------------------------------------
    uniform float uTime;
    uniform float uRatio; // 0.0 = Tree (合拢), 1.0 = Chaos (散开)
    
    attribute vec3 aPositionTree;  // 树形态的目标位置
    attribute vec3 aPositionChaos; // 散开形态的目标位置
    attribute float aSize;         // 粒子大小
    attribute vec3 aColor;         // 粒子颜色
    
    varying vec3 vColor;
    varying float vAlpha;

    // 伪随机函数
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
        vColor = aColor;
        
        // 混合位置： $$ P = P_{tree} * (1 - r) + P_{chaos} * r $$
        vec3 stablePos = mix(aPositionTree, aPositionChaos, uRatio);

        // 添加动态呼吸感 (Noise)
        // 在散开状态下，粒子会有更大幅度的漂浮
        float floatIntensity = mix(0.2, 2.0, uRatio); 
        float speed = mix(1.0, 0.5, uRatio);
        
        vec3 finalPos = stablePos;
        finalPos.x += sin(uTime * speed + stablePos.y) * floatIntensity * 0.1;
        finalPos.y += cos(uTime * speed + stablePos.x) * floatIntensity * 0.1;
        finalPos.z += sin(uTime * speed + stablePos.z) * floatIntensity * 0.1;

        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        // 大小随距离衰减 $$ size \propto 1/z $$
        // 在散开状态下，特定粒子(如照片)放大
        float sizeMult = 1.0;
        if(uRatio > 0.8 && aSize > 20.0) { // 假设 size > 20 是照片节点
             sizeMult = 2.5; 
        }

        gl_PointSize = (aSize * sizeMult) * (300.0 / -mvPosition.z);
        
        // 简单的淡入淡出效果
        vAlpha = 1.0;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    // --------------------------------------------------------
    // Fragment Shader: 绘制发光的圆形粒子
    // --------------------------------------------------------
    uniform float uTime;
    varying vec3 vColor;
    varying float vAlpha;

    void main() {
        // 计算距中心的距离
        vec2 uv = gl_PointCoord.xy - 0.5;
        float dist = length(uv);

        // 绘制柔和的圆形 (Glow)
        // $$ alpha = 0.05 / (dist - 0.05) $$ 近似辉光
        float circle = 1.0 - smoothstep(0.3, 0.5, dist);
        
        // 核心亮点
        float core = 1.0 - smoothstep(0.0, 0.15, dist);

        if (dist > 0.5) discard;

        // 最终颜色混合
        vec3 finalColor = vColor + core * 0.8; // 增加中心亮度

        gl_FragColor = vec4(finalColor, circle * vAlpha);
    }
</script>

<script>
    /**
     * 配置参数
     */
    const CONFIG = {
        colors: {
            matteGreen: new THREE.Color('#2F5A2F'),
            gold: new THREE.Color('#FFD700'),
            red: new THREE.Color('#B22222'),
            white: new THREE.Color('#FFFFFF'),
            photoBase: new THREE.Color('#E0E0E0') 
        },
        particleCount: 8000,
        textParticles: 3000,
        treeHeight: 60,
        treeRadius: 25
    };

    /**
     * 全局变量
     */
    let scene, camera, renderer, composer;
    let material, particlesGeometry, points;
    let handLandmarks = null;
    let targetRatio = 0.0; // 0 = Closed, 1 = Open
    let currentRatio = 0.0;
    let videoElement;

    /**
     * 主程序入口 - 等待所有资源加载完成
     */
    let initializationStarted = false;
    let threeReady = false;
    let mediapipeReady = false;
    
    function checkAndInit() {
        if (initializationStarted) return;
        if (!threeReady) {
            console.log('等待 Three.js 加载...');
            return;
        }
        // MediaPipe 不是必需的，即使未加载也继续
        if (!mediapipeReady) {
            console.log('等待 MediaPipe 加载（可选）...');
            // 如果 Three.js 已加载，等待最多 2 秒后继续
            return;
        }
        
        initializationStarted = true;
        console.log('开始初始化场景...');
        try {
            init();
            initMediaPipe();
            animate();
            // 立即隐藏加载提示
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
        } catch (error) {
            console.error('初始化错误:', error);
            document.getElementById('loading').textContent = '初始化失败: ' + error.message;
        }
    }
    
    // 等待 Three.js 加载
    function checkThreeLoaded() {
        if (window.THREE && window.THREE.Scene) {
            threeReady = true;
            console.log('Three.js 已加载');
            checkAndInit();
            return true;
        }
        return false;
    }
    
    if (window.threeLoaded || checkThreeLoaded()) {
        threeReady = true;
        checkAndInit();
    } else {
        window.onThreeLoaded = () => {
            threeReady = true;
            console.log('Three.js 加载完成（通过回调）');
            checkAndInit();
        };
        
        // 每 100ms 检查一次 Three.js 是否加载
        const checkThree = setInterval(() => {
            if (checkThreeLoaded()) {
                clearInterval(checkThree);
            }
        }, 100);
        
        // 10秒超时，即使 Three.js 未加载也尝试初始化（可能会失败但至少不会卡住）
        setTimeout(() => {
            clearInterval(checkThree);
            if (!threeReady) {
                console.error('Three.js 加载超时，尝试使用备用方案');
                // 尝试直接使用 window.THREE（如果存在）
                if (window.THREE) {
                    threeReady = true;
                    checkAndInit();
                } else {
                    document.getElementById('loading').textContent = 'Three.js 加载失败，请检查网络连接';
                }
            }
        }, 10000);
    }
    
    // 等待 MediaPipe 加载（可选）
    function checkMediaPipeLoaded() {
        // MediaPipe 可能通过不同的方式暴露，检查多种可能
        if ((typeof Hands !== 'undefined' && typeof Camera !== 'undefined') ||
            (window.Hands && window.Camera)) {
            mediapipeReady = true;
            console.log('MediaPipe 已加载');
            checkAndInit();
            return true;
        }
        return false;
    }
    
    if (checkMediaPipeLoaded()) {
        // 已加载
    } else {
        // 监听 MediaPipe 加载
        const checkMediaPipe = setInterval(() => {
            if (checkMediaPipeLoaded()) {
                clearInterval(checkMediaPipe);
            }
        }, 100);
        
        // 2秒超时，即使 MediaPipe 未加载也继续（场景仍可显示）
        setTimeout(() => {
            clearInterval(checkMediaPipe);
            if (!mediapipeReady) {
                console.warn('MediaPipe 加载超时，继续初始化（无摄像头功能）');
                mediapipeReady = true; // 允许继续
                checkAndInit();
            }
        }, 2000);
    }

    function init() {
        // 1. Scene Setup
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        // 雾效增强深邃感
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        // 2. Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 80;
        camera.position.y = 20;

        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x050505);
        container.appendChild(renderer.domElement);

        // 4. Particles Generation
        generateParticles();

        // 5. Post Processing (Bloom)
        try {
            // 尝试多种方式获取后处理类
            let RenderPassClass = window.RenderPass || (typeof RenderPass !== 'undefined' ? RenderPass : null);
            let UnrealBloomPassClass = window.UnrealBloomPass || (typeof UnrealBloomPass !== 'undefined' ? UnrealBloomPass : null);
            let EffectComposerClass = window.EffectComposer || (typeof EffectComposer !== 'undefined' ? EffectComposer : null);
            
            // 如果使用 UMD 版本，类可能在 THREE 命名空间下
            if (!RenderPassClass && window.THREE && window.THREE.RenderPass) {
                RenderPassClass = window.THREE.RenderPass;
                UnrealBloomPassClass = window.THREE.UnrealBloomPass;
                EffectComposerClass = window.THREE.EffectComposer;
            }
            
            if (RenderPassClass && UnrealBloomPassClass && EffectComposerClass) {
                const renderScene = new RenderPassClass(scene, camera);
                
                // UnrealBloomPass 参数: resolution, strength, radius, threshold
                // $$ strength = 1.5, radius = 0.4, threshold = 0.85 $$
                const bloomPass = new UnrealBloomPassClass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.strength = 1.8;
                bloomPass.radius = 0.5;
                bloomPass.threshold = 0.1; // 阈值低一点让绿色也能发光

                composer = new EffectComposerClass(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            } else {
                throw new Error('后处理类未找到');
            }
        } catch (error) {
            console.warn('后处理效果初始化失败，使用基础渲染:', error);
            composer = null; // 如果后处理失败，使用基础渲染器
        }

        // Resize Listener
        window.addEventListener('resize', onWindowResize, false);
    }

    function generateParticles() {
        const totalParticles = CONFIG.particleCount + CONFIG.textParticles;
        
        const posTree = [];
        const posChaos = [];
        const colors = [];
        const sizes = [];

        // --- Helper: Text Sampling ---
        // 生成文字坐标: "冯禾子涵" 和 "fenghezihan"
        const textCoords = getTextCoordinates("冯禾子涵 fenghezihan");
        
        // --- Loop Generation ---
        for (let i = 0; i < totalParticles; i++) {
            
            // 1. Attributes for Tree State (Conical Spiral)
            // 螺旋方程: $$ x = r \cos(\theta), z = r \sin(\theta), y = h $$
            // $$ r $$ 随 $$ y $$ 增加而减小
            
            let pTree = new THREE.Vector3();
            let color = new THREE.Color();
            let size = 0.0;
            let isText = false;

            if (i < CONFIG.textParticles && i < textCoords.length) {
                // 文字粒子
                isText = true;
                // 将文字映射到树的表面或者树的内部
                const tc = textCoords[i];
                // 缩放并移动文字使其位于树的前方
                pTree.set((tc.x - 150) * 0.15, (100 - tc.y) * 0.15 + 10, 20 + (Math.random()*5)); 
                color = CONFIG.colors.gold;
                size = 4.0;
            } else {
                // 树体粒子
                const turn = Math.random() * Math.PI * 20; // 10圈
                const h = Math.random() * CONFIG.treeHeight; // 高度 0 - 60
                const rNorm = (CONFIG.treeHeight - h) / CONFIG.treeHeight; // 归一化半径 (底部1，顶部0)
                const r = rNorm * CONFIG.treeRadius; 
                
                pTree.x = Math.cos(turn) * r;
                pTree.z = Math.sin(turn) * r;
                pTree.y = h - (CONFIG.treeHeight / 2);

                // 2. Color Logic
                const mixRand = Math.random();
                if (mixRand > 0.95) {
                    color = CONFIG.colors.red; // 装饰球
                    size = 12.0;
                } else if (mixRand > 0.85) {
                    color = CONFIG.colors.gold; // 金色点缀
                    size = 8.0;
                } else if (mixRand > 0.82) {
                    color = CONFIG.colors.photoBase; // 照片云占位符
                    size = 25.0; // 较大的正方形粒子
                } else {
                    color = CONFIG.colors.matteGreen; // 树叶
                    // 绿色有深浅变化
                    color.multiplyScalar(0.5 + Math.random() * 0.5);
                    size = 3.0;
                }
            }

            posTree.push(pTree.x, pTree.y, pTree.z);
            colors.push(color.r, color.g, color.b);
            sizes.push(size);

            // 3. Attributes for Chaos State (Sphere/Explosion)
            // 随机分布在球体内
            const rChaos = 60 * Math.cbrt(Math.random()); // 立方根保证均匀分布
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            
            let pChaos = new THREE.Vector3(
                rChaos * Math.sin(phi) * Math.cos(theta),
                rChaos * Math.sin(phi) * Math.sin(theta),
                rChaos * Math.cos(phi)
            );
            
            // 文字粒子在散开时，仍然保持一定的聚集，但稍微散开
            if(isText) {
                pChaos.add(new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20));
            }

            posChaos.push(pChaos.x, pChaos.y, pChaos.z);
        }

        // Create Geometry
        particlesGeometry = new THREE.BufferGeometry();
        particlesGeometry.setAttribute('aPositionTree', new THREE.Float32BufferAttribute(posTree, 3));
        particlesGeometry.setAttribute('aPositionChaos', new THREE.Float32BufferAttribute(posChaos, 3));
        particlesGeometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        particlesGeometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        
        // Create Material
        material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uRatio: { value: 0 }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending // 这种混合模式配合 Bloom 效果最好
        });

        points = new THREE.Points(particlesGeometry, material);
        scene.add(points);
    }

    // Canvas 文字取点
    function getTextCoordinates(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const width = 600;
        const height = 200;
        canvas.width = width;
        canvas.height = height;
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);
        
        ctx.font = 'bold 80px "Microsoft YaHei", sans-serif';
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, width / 2, height / 2);

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const coords = [];
        
        // 采样步长，越小点越多
        const step = 4; 
        
        for(let y = 0; y < height; y += step) {
            for(let x = 0; x < width; x += step) {
                const index = (y * width + x) * 4;
                if(data[index] > 128) { // 红色通道 > 128 认为是字
                    coords.push({x: x - width/4, y: y}); // Offset center
                }
            }
        }
        return coords;
    }

    function initMediaPipe() {
        // 尝试多种方式获取 MediaPipe 类
        const HandsClass = window.Hands || (typeof Hands !== 'undefined' ? Hands : null);
        const CameraClass = window.Camera || (typeof Camera !== 'undefined' ? Camera : null);
        
        if (!HandsClass || !CameraClass) {
            console.warn('MediaPipe 未加载，跳过摄像头初始化');
            document.getElementById('loading').classList.add('hidden');
            return;
        }
        
        videoElement = document.getElementById('video-input');
        
        try {
            const hands = new HandsClass({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new CameraClass(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            // Camera.start() 可能返回 Promise 或直接执行
            if (cameraUtils.start && typeof cameraUtils.start === 'function') {
                const startResult = cameraUtils.start();
                if (startResult && typeof startResult.catch === 'function') {
                    startResult.catch((error) => {
                        console.error('摄像头启动失败:', error);
                        document.getElementById('loading').classList.add('hidden');
                    });
                }
            }
        } catch (error) {
            console.error('MediaPipe 初始化错误:', error);
            document.getElementById('loading').classList.add('hidden');
        }
    }

    function onHandsResults(results) {
        document.getElementById('loading').classList.add('hidden');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            handLandmarks = landmarks;

            // 1. Detect Gesture: Open vs Fist
            // 简单算法：计算指尖 (Tip) 到 指根 (MCP) 的距离
            // 如果 4 个手指（食指到小指）都折叠，则为 Fist
            
            const fingerTips = [8, 12, 16, 20];
            const fingerMCPs = [5, 9, 13, 17];
            let extendedFingers = 0;

            for (let i = 0; i < 4; i++) {
                const tip = landmarks[fingerTips[i]];
                const mcp = landmarks[fingerMCPs[i]];
                const wrist = landmarks[0];
                
                // 计算距离 $$ d = \sqrt{(x_1-x_2)^2 + ...} $$
                const distTipWrist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                const distMcpWrist = Math.hypot(mcp.x - wrist.x, mcp.y - wrist.y);

                if (distTipWrist > distMcpWrist * 1.2) { // 指尖离手腕明显比指根远
                    extendedFingers++;
                }
            }

            // 状态机切换
            if (extendedFingers >= 3) {
                // Open Hand -> Chaos Mode
                targetRatio = 1.0;
            } else if (extendedFingers <= 1) {
                // Fist -> Tree Mode
                targetRatio = 0.0;
            }

            // 2. Camera Interaction (Based on Palm Position)
            // 只有在 Open 状态下启用旋转
            if (targetRatio > 0.5) {
                const palmX = landmarks[9].x; // Middle finger MCP
                const palmY = landmarks[9].y;
                
                // 将 0-1 的坐标映射到相机角度
                // $$ \theta = (x - 0.5) * sensitivity $$
                const targetRotX = (palmY - 0.5) * 1.0; 
                const targetRotY = (palmX - 0.5) * 1.0;
                
                // 平滑移动相机
                camera.position.x += (Math.sin(targetRotY * 2) * 60 - camera.position.x) * 0.05;
                camera.position.y += (Math.cos(targetRotX) * 30 - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            } else {
                // Reset Camera slowly
                 camera.position.x += (0 - camera.position.x) * 0.05;
                 camera.position.y += (20 - camera.position.y) * 0.05;
                 camera.lookAt(0, 0, 0);
            }

        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() * 0.001;
        
        // 1. Update Shader Uniforms
        if (material) {
            material.uniforms.uTime.value = time;
            
            // 平滑插值 ratio $$ val = val + (target - val) * factor $$
            currentRatio += (targetRatio - currentRatio) * 0.05;
            material.uniforms.uRatio.value = currentRatio;
        }

        // 2. Scene Rotation (Auto rotate slightly for aesthetic)
        if (points) {
            points.rotation.y = time * 0.05;
        }

        // 3. Render via Composer (Bloom) or basic renderer
        if (composer) {
            composer.render();
        } else {
            renderer.render(scene, camera);
        }
    }

</script>
</body>
</html>