<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Gesture Controlled Christmas Tree | Sen's World</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Merriweather', 'Helvetica Neue', sans-serif; 
        }
        body.dark {
            background-color: #121212;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        #video-input { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            width: 160px; 
            height: 120px; 
            z-index: 2; 
            border-radius: 8px; 
            opacity: 0.6; 
            transform: scaleX(-1); 
            border: 1px solid rgba(255, 215, 0, 0.3); 
            transition: opacity 0.3s;
        }
        body.dark #video-input {
            border-color: rgba(243, 156, 18, 0.4);
        }
        #loading { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #FFD700; 
            font-size: 24px; 
            z-index: 10; 
            letter-spacing: 2px; 
            text-transform: uppercase; 
            pointer-events: none; 
            transition: opacity 0.5s; 
            font-family: 'Playfair Display', serif;
        }
        body.dark #loading {
            color: #f39c12;
        }
        .hidden { opacity: 0; }
    </style>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "rhkatcquvv");
    </script>
</head>
<body>
  <script>
    (function() {
      try {
        var theme = localStorage.getItem('theme');
        var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (theme === 'dark' || (!theme && prefersDark)) {
          document.body.classList.add('dark');
        }
      } catch (e) {
        console.error('Error applying initial theme:', e);
      }
    })();
  </script>

    <div id="loading">System Initializing...</div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

<script type="x-shader/x-vertex" id="vertexshader">
    // --------------------------------------------------------
    // Vertex Shader: 处理粒子位置混合 (Morphing)
    // --------------------------------------------------------
    uniform float uTime;
    uniform float uRatio; // 0.0 = Tree (合拢), 1.0 = Chaos (散开)
    
    attribute vec3 aPositionTree;  // 树形态的目标位置
    attribute vec3 aPositionChaos; // 散开形态的目标位置
    attribute float aSize;         // 粒子大小
    attribute vec3 aColor;         // 粒子颜色
    
    varying vec3 vColor;
    varying float vAlpha;

    // 伪随机函数
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
        vColor = aColor;
        
        // 混合位置： $$ P = P_{tree} * (1 - r) + P_{chaos} * r $$
        vec3 stablePos = mix(aPositionTree, aPositionChaos, uRatio);

        // 添加动态呼吸感 (Noise)
        // 在散开状态下，粒子会有更大幅度的漂浮
        float floatIntensity = mix(0.2, 2.0, uRatio); 
        float speed = mix(1.0, 0.5, uRatio);
        
        vec3 finalPos = stablePos;
        finalPos.x += sin(uTime * speed + stablePos.y) * floatIntensity * 0.1;
        finalPos.y += cos(uTime * speed + stablePos.x) * floatIntensity * 0.1;
        finalPos.z += sin(uTime * speed + stablePos.z) * floatIntensity * 0.1;

        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        // 大小随距离衰减 $$ size \propto 1/z $$
        // 在散开状态下，特定粒子(如照片)放大
        float sizeMult = 1.0;
        if(uRatio > 0.8 && aSize > 20.0) { // 假设 size > 20 是照片节点
             sizeMult = 2.5; 
        }

        gl_PointSize = (aSize * sizeMult) * (300.0 / -mvPosition.z);
        
        // 简单的淡入淡出效果
        vAlpha = 1.0;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    // --------------------------------------------------------
    // Fragment Shader: 绘制发光的圆形粒子
    // --------------------------------------------------------
    uniform float uTime;
    varying vec3 vColor;
    varying float vAlpha;

    void main() {
        // 计算距中心的距离
        vec2 uv = gl_PointCoord.xy - 0.5;
        float dist = length(uv);

        // 绘制柔和的圆形 (Glow)
        // $$ alpha = 0.05 / (dist - 0.05) $$ 近似辉光
        float circle = 1.0 - smoothstep(0.3, 0.5, dist);
        
        // 核心亮点
        float core = 1.0 - smoothstep(0.0, 0.15, dist);

        if (dist > 0.5) discard;

        // 最终颜色混合
        vec3 finalColor = vColor + core * 0.8; // 增加中心亮度

        gl_FragColor = vec4(finalColor, circle * vAlpha);
    }
</script>

<script>
    /**
     * 配置参数
     */
    const CONFIG = {
        colors: {
            matteGreen: new THREE.Color('#2F5A2F'),
            gold: new THREE.Color('#FFD700'),
            red: new THREE.Color('#B22222'),
            white: new THREE.Color('#FFFFFF'),
            photoBase: new THREE.Color('#E0E0E0') 
        },
        particleCount: 8000,
        textParticles: 3000,
        treeHeight: 60,
        treeRadius: 25
    };

    /**
     * 全局变量
     */
    let scene, camera, renderer, composer;
    let material, particlesGeometry, points;
    let handLandmarks = null;
    let targetRatio = 0.0; // 0 = Closed, 1 = Open
    let currentRatio = 0.0;
    let videoElement;

    /**
     * 主程序入口
     */
    init();
    initMediaPipe();
    animate();

    function init() {
        // 1. Scene Setup
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        // 雾效增强深邃感
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        // 2. Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 80;
        camera.position.y = 20;

        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x050505);
        container.appendChild(renderer.domElement);

        // 4. Particles Generation
        generateParticles();

        // 5. Post Processing (Bloom)
        const renderScene = new THREE.RenderPass(scene, camera);
        
        // UnrealBloomPass 参数: resolution, strength, radius, threshold
        // $$ strength = 1.5, radius = 0.4, threshold = 0.85 $$
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 1.8;
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.1; // 阈值低一点让绿色也能发光

        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Resize Listener
        window.addEventListener('resize', onWindowResize, false);
    }

    function generateParticles() {
        const totalParticles = CONFIG.particleCount + CONFIG.textParticles;
        
        const posTree = [];
        const posChaos = [];
        const colors = [];
        const sizes = [];

        // --- Helper: Text Sampling ---
        // 生成文字坐标: "冯禾子涵" 和 "fenghezihan"
        const textCoords = getTextCoordinates("冯禾子涵 fenghezihan");
        
        // --- Loop Generation ---
        for (let i = 0; i < totalParticles; i++) {
            
            // 1. Attributes for Tree State (Conical Spiral)
            // 螺旋方程: $$ x = r \cos(\theta), z = r \sin(\theta), y = h $$
            // $$ r $$ 随 $$ y $$ 增加而减小
            
            let pTree = new THREE.Vector3();
            let color = new THREE.Color();
            let size = 0.0;
            let isText = false;

            if (i < CONFIG.textParticles && i < textCoords.length) {
                // 文字粒子
                isText = true;
                // 将文字映射到树的表面或者树的内部
                const tc = textCoords[i];
                // 缩放并移动文字使其位于树的前方
                pTree.set((tc.x - 150) * 0.15, (100 - tc.y) * 0.15 + 10, 20 + (Math.random()*5)); 
                color = CONFIG.colors.gold;
                size = 4.0;
            } else {
                // 树体粒子
                const turn = Math.random() * Math.PI * 20; // 10圈
                const h = Math.random() * CONFIG.treeHeight; // 高度 0 - 60
                const rNorm = (CONFIG.treeHeight - h) / CONFIG.treeHeight; // 归一化半径 (底部1，顶部0)
                const r = rNorm * CONFIG.treeRadius; 
                
                pTree.x = Math.cos(turn) * r;
                pTree.z = Math.sin(turn) * r;
                pTree.y = h - (CONFIG.treeHeight / 2);

                // 2. Color Logic
                const mixRand = Math.random();
                if (mixRand > 0.95) {
                    color = CONFIG.colors.red; // 装饰球
                    size = 12.0;
                } else if (mixRand > 0.85) {
                    color = CONFIG.colors.gold; // 金色点缀
                    size = 8.0;
                } else if (mixRand > 0.82) {
                    color = CONFIG.colors.photoBase; // 照片云占位符
                    size = 25.0; // 较大的正方形粒子
                } else {
                    color = CONFIG.colors.matteGreen; // 树叶
                    // 绿色有深浅变化
                    color.multiplyScalar(0.5 + Math.random() * 0.5);
                    size = 3.0;
                }
            }

            posTree.push(pTree.x, pTree.y, pTree.z);
            colors.push(color.r, color.g, color.b);
            sizes.push(size);

            // 3. Attributes for Chaos State (Sphere/Explosion)
            // 随机分布在球体内
            const rChaos = 60 * Math.cbrt(Math.random()); // 立方根保证均匀分布
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            
            let pChaos = new THREE.Vector3(
                rChaos * Math.sin(phi) * Math.cos(theta),
                rChaos * Math.sin(phi) * Math.sin(theta),
                rChaos * Math.cos(phi)
            );
            
            // 文字粒子在散开时，仍然保持一定的聚集，但稍微散开
            if(isText) {
                pChaos.add(new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20));
            }

            posChaos.push(pChaos.x, pChaos.y, pChaos.z);
        }

        // Create Geometry
        particlesGeometry = new THREE.BufferGeometry();
        particlesGeometry.setAttribute('aPositionTree', new THREE.Float32BufferAttribute(posTree, 3));
        particlesGeometry.setAttribute('aPositionChaos', new THREE.Float32BufferAttribute(posChaos, 3));
        particlesGeometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        particlesGeometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        
        // Create Material
        material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uRatio: { value: 0 }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending // 这种混合模式配合 Bloom 效果最好
        });

        points = new THREE.Points(particlesGeometry, material);
        scene.add(points);
    }

    // Canvas 文字取点
    function getTextCoordinates(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const width = 600;
        const height = 200;
        canvas.width = width;
        canvas.height = height;
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);
        
        ctx.font = 'bold 80px "Microsoft YaHei", sans-serif';
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, width / 2, height / 2);

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const coords = [];
        
        // 采样步长，越小点越多
        const step = 4; 
        
        for(let y = 0; y < height; y += step) {
            for(let x = 0; x < width; x += step) {
                const index = (y * width + x) * 4;
                if(data[index] > 128) { // 红色通道 > 128 认为是字
                    coords.push({x: x - width/4, y: y}); // Offset center
                }
            }
        }
        return coords;
    }

    function initMediaPipe() {
        videoElement = document.getElementById('video-input');
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandsResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();
    }

    function onHandsResults(results) {
        document.getElementById('loading').classList.add('hidden');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            handLandmarks = landmarks;

            // 1. Detect Gesture: Open vs Fist
            // 简单算法：计算指尖 (Tip) 到 指根 (MCP) 的距离
            // 如果 4 个手指（食指到小指）都折叠，则为 Fist
            
            const fingerTips = [8, 12, 16, 20];
            const fingerMCPs = [5, 9, 13, 17];
            let extendedFingers = 0;

            for (let i = 0; i < 4; i++) {
                const tip = landmarks[fingerTips[i]];
                const mcp = landmarks[fingerMCPs[i]];
                const wrist = landmarks[0];
                
                // 计算距离 $$ d = \sqrt{(x_1-x_2)^2 + ...} $$
                const distTipWrist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                const distMcpWrist = Math.hypot(mcp.x - wrist.x, mcp.y - wrist.y);

                if (distTipWrist > distMcpWrist * 1.2) { // 指尖离手腕明显比指根远
                    extendedFingers++;
                }
            }

            // 状态机切换
            if (extendedFingers >= 3) {
                // Open Hand -> Chaos Mode
                targetRatio = 1.0;
            } else if (extendedFingers <= 1) {
                // Fist -> Tree Mode
                targetRatio = 0.0;
            }

            // 2. Camera Interaction (Based on Palm Position)
            // 只有在 Open 状态下启用旋转
            if (targetRatio > 0.5) {
                const palmX = landmarks[9].x; // Middle finger MCP
                const palmY = landmarks[9].y;
                
                // 将 0-1 的坐标映射到相机角度
                // $$ \theta = (x - 0.5) * sensitivity $$
                const targetRotX = (palmY - 0.5) * 1.0; 
                const targetRotY = (palmX - 0.5) * 1.0;
                
                // 平滑移动相机
                camera.position.x += (Math.sin(targetRotY * 2) * 60 - camera.position.x) * 0.05;
                camera.position.y += (Math.cos(targetRotX) * 30 - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            } else {
                // Reset Camera slowly
                 camera.position.x += (0 - camera.position.x) * 0.05;
                 camera.position.y += (20 - camera.position.y) * 0.05;
                 camera.lookAt(0, 0, 0);
            }

        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() * 0.001;
        
        // 1. Update Shader Uniforms
        if (material) {
            material.uniforms.uTime.value = time;
            
            // 平滑插值 ratio $$ val = val + (target - val) * factor $$
            currentRatio += (targetRatio - currentRatio) * 0.05;
            material.uniforms.uRatio.value = currentRatio;
        }

        // 2. Scene Rotation (Auto rotate slightly for aesthetic)
        if (points) {
            points.rotation.y = time * 0.05;
        }

        // 3. Render via Composer (Bloom)
        composer.render();
    }

</script>
</body>
</html>