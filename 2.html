<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Gesture Controlled Christmas Tree | Sen's World</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            font-family: 'Merriweather', serif;
            color: #FFD700;
        }
        
        body.dark {
            background: linear-gradient(135deg, #050505 0%, #121212 100%);
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        #video-input {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            z-index: 2;
            border-radius: 8px;
            opacity: 0.6;
            transform: scaleX(-1);
            border: 2px solid rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            transition: opacity 0.3s;
        }
        
        body.dark #video-input {
            border-color: rgba(243, 156, 18, 0.6);
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.4);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 28px;
            z-index: 10;
            letter-spacing: 4px;
            text-transform: uppercase;
            pointer-events: none;
            transition: opacity 0.5s;
            font-family: 'Playfair Display', serif;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        body.dark #loading {
            color: #f39c12;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.8);
        }
        
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 3;
            color: #FFD700;
            font-size: 14px;
            font-family: 'Playfair Display', serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        body.dark #status {
            color: #f39c12;
            border-color: rgba(243, 156, 18, 0.3);
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        window.THREE = THREE;
        window.EffectComposer = EffectComposer;
        window.RenderPass = RenderPass;
        window.UnrealBloomPass = UnrealBloomPass;
        window.threeLoaded = true;
        if (window.onThreeLoaded) window.onThreeLoaded();
    </script>
    <script>
        const threeUMDScript = document.createElement('script');
        threeUMDScript.src = 'https://unpkg.com/three@0.160.0/build/three.min.js';
        threeUMDScript.onload = () => {
            const postProcessingScripts = [
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/EffectComposer.js',
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/RenderPass.js',
                'https://unpkg.com/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js'
            ];
            let loadedCount = 0;
            postProcessingScripts.forEach((src) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => {
                    loadedCount++;
                    if (loadedCount === postProcessingScripts.length && !window.threeLoaded && window.THREE) {
                        window.threeLoaded = true;
                        window.threeUMD = true;
                        if (window.onThreeLoaded) window.onThreeLoaded();
                    }
                };
                document.head.appendChild(script);
            });
        };
        document.head.appendChild(threeUMDScript);
        
        setTimeout(() => {
            if (!window.threeLoaded && window.THREE) {
                window.threeLoaded = true;
                window.threeUMD = true;
                if (window.onThreeLoaded) window.onThreeLoaded();
            }
        }, 3000);
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "rhkatcquvv");
    </script>
</head>
<body>
  <script>
    (function() {
      try {
        var theme = localStorage.getItem('theme');
        var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (theme === 'dark' || (!theme && prefersDark)) {
          document.body.classList.add('dark');
        }
      } catch (e) {
        console.error('Error applying initial theme:', e);
      }
    })();
  </script>

    <div id="loading">System Initializing...</div>
    <div id="status">状态: 初始化中</div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

<script>
    /**
     * 配置参数
     */
    const CONFIG = {
        colors: {
            matteGreen: new THREE.Color('#2F5A2F'),
            gold: new THREE.Color('#FFD700'),
            red: new THREE.Color('#B22222'),
            white: new THREE.Color('#FFFFFF'),
            photoBase: new THREE.Color('#E0E0E0')
        },
        // 粒子数量配置
        sphereCount: 200,      // 球体装饰
        boxCount: 150,         // 正方体装饰
        candyCount: 100,       // 糖果棍
        photoCount: 20,        // 照片云
        textParticles: 4000,   // 文字粒子
        treeHeight: 60,
        treeRadius: 25,
        // 状态切换速度
        transitionSpeed: 0.05
    };

    /**
     * 全局变量
     */
    let scene, camera, renderer, composer;
    let particlesGroup;
    let handLandmarks = null;
    let targetState = 'closed'; // 'closed', 'open', 'photo'
    let currentStateRatio = 0.0; // 0 = closed, 1 = open
    let videoElement;
    let cameraTargetX = 0;
    let cameraTargetY = 20;
    let cameraTargetZ = 80;
    let cameraRotationX = 0;
    let cameraRotationY = 0;
    
    // 存储所有粒子的初始位置和目标位置
    let particleData = [];

    /**
     * 初始化函数
     */
    function init() {
        const container = document.getElementById('canvas-container');
        
        // 1. Scene Setup
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        // 2. Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 80);
        camera.lookAt(0, 0, 0);

        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x050505);
        container.appendChild(renderer.domElement);

        // 4. 创建粒子组
        particlesGroup = new THREE.Group();
        scene.add(particlesGroup);

        // 5. 生成所有粒子
        generateParticles();

        // 6. Post Processing (Bloom)
        setupPostProcessing();

        // 7. Resize Listener
        window.addEventListener('resize', onWindowResize, false);
    }

    /**
     * 生成所有粒子
     */
    function generateParticles() {
        particleData = [];
        
        // 生成文字粒子坐标
        const textCoords = getTextCoordinates("冯禾子涵 fenghezihan");
        
        // 1. 球体装饰
        for (let i = 0; i < CONFIG.sphereCount; i++) {
            const geometry = new THREE.SphereGeometry(0.8, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.7 ? CONFIG.colors.red : CONFIG.colors.gold,
                emissive: Math.random() > 0.7 ? CONFIG.colors.red : CONFIG.colors.gold,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            const treePos = getTreePosition();
            const chaosPos = getChaosPosition();
            
            mesh.position.copy(treePos);
            particleData.push({
                mesh: mesh,
                treePos: treePos.clone(),
                chaosPos: chaosPos.clone(),
                type: 'sphere'
            });
            particlesGroup.add(mesh);
        }

        // 2. 正方体装饰
        for (let i = 0; i < CONFIG.boxCount; i++) {
            const size = 0.6 + Math.random() * 0.4;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.gold,
                emissive: CONFIG.colors.gold,
                emissiveIntensity: 0.4,
                metalness: 0.9,
                roughness: 0.1
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            const treePos = getTreePosition();
            const chaosPos = getChaosPosition();
            
            mesh.position.copy(treePos);
            particleData.push({
                mesh: mesh,
                treePos: treePos.clone(),
                chaosPos: chaosPos.clone(),
                type: 'box'
            });
            particlesGroup.add(mesh);
        }

        // 3. 糖果棍
        for (let i = 0; i < CONFIG.candyCount; i++) {
            const geometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
            const material = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.5 ? CONFIG.colors.red : CONFIG.colors.white,
                emissive: Math.random() > 0.5 ? CONFIG.colors.red : CONFIG.colors.white,
                emissiveIntensity: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.z = Math.random() * Math.PI;
            
            const treePos = getTreePosition();
            const chaosPos = getChaosPosition();
            
            mesh.position.copy(treePos);
            particleData.push({
                mesh: mesh,
                treePos: treePos.clone(),
                chaosPos: chaosPos.clone(),
                type: 'candy'
            });
            particlesGroup.add(mesh);
        }

        // 4. 照片云
        for (let i = 0; i < CONFIG.photoCount; i++) {
            const width = 3 + Math.random() * 2;
            const height = 4 + Math.random() * 2;
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.photoBase,
                emissive: CONFIG.colors.photoBase,
                emissiveIntensity: 0.2,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            const treePos = getTreePosition();
            const chaosPos = getChaosPosition();
            
            mesh.position.copy(treePos);
            mesh.lookAt(camera.position);
            particleData.push({
                mesh: mesh,
                treePos: treePos.clone(),
                chaosPos: chaosPos.clone(),
                type: 'photo',
                photoIndex: i
            });
            particlesGroup.add(mesh);
        }

        // 5. 文字粒子
        for (let i = 0; i < CONFIG.textParticles && i < textCoords.length; i++) {
            const geometry = new THREE.SphereGeometry(0.3, 6, 6);
            const material = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.gold,
                emissive: CONFIG.colors.gold,
                emissiveIntensity: 0.8,
                metalness: 0.9,
                roughness: 0.1
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            const tc = textCoords[i];
            const treePos = new THREE.Vector3(
                (tc.x - 150) * 0.15,
                (100 - tc.y) * 0.15 + 10,
                20 + Math.random() * 5
            );
            const chaosPos = getChaosPosition();
            chaosPos.add(new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20
            ));
            
            mesh.position.copy(treePos);
            particleData.push({
                mesh: mesh,
                treePos: treePos.clone(),
                chaosPos: chaosPos.clone(),
                type: 'text'
            });
            particlesGroup.add(mesh);
        }
    }

    /**
     * 获取圣诞树位置（圆锥形）
     */
    function getTreePosition() {
        const turn = Math.random() * Math.PI * 20;
        const h = Math.random() * CONFIG.treeHeight;
        const rNorm = (CONFIG.treeHeight - h) / CONFIG.treeHeight;
        const r = rNorm * CONFIG.treeRadius;
        
        return new THREE.Vector3(
            Math.cos(turn) * r,
            h - (CONFIG.treeHeight / 2),
            Math.sin(turn) * r
        );
    }

    /**
     * 获取散开位置（球体内随机）
     */
    function getChaosPosition() {
        const rChaos = 60 * Math.cbrt(Math.random());
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        
        return new THREE.Vector3(
            rChaos * Math.sin(phi) * Math.cos(theta),
            rChaos * Math.sin(phi) * Math.sin(theta),
            rChaos * Math.cos(phi)
        );
    }

    /**
     * 获取文字坐标
     */
    function getTextCoordinates(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const width = 600;
        const height = 200;
        canvas.width = width;
        canvas.height = height;
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);
        
        ctx.font = 'bold 80px "Microsoft YaHei", sans-serif';
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, width / 2, height / 2);

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const coords = [];
        
        const step = 3;
        for(let y = 0; y < height; y += step) {
            for(let x = 0; x < width; x += step) {
                const index = (y * width + x) * 4;
                if(data[index] > 128) {
                    coords.push({x: x - width/4, y: y});
                }
            }
        }
        return coords;
    }

    /**
     * 设置后处理效果
     */
    function setupPostProcessing() {
        try {
            const RenderPassClass = window.RenderPass || (typeof RenderPass !== 'undefined' ? RenderPass : null);
            const UnrealBloomPassClass = window.UnrealBloomPass || (typeof UnrealBloomPass !== 'undefined' ? UnrealBloomPass : null);
            const EffectComposerClass = window.EffectComposer || (typeof EffectComposer !== 'undefined' ? EffectComposer : null);
            
            if (!RenderPassClass && window.THREE && window.THREE.RenderPass) {
                RenderPassClass = window.THREE.RenderPass;
                UnrealBloomPassClass = window.THREE.UnrealBloomPass;
                EffectComposerClass = window.THREE.EffectComposer;
            }
            
            if (RenderPassClass && UnrealBloomPassClass && EffectComposerClass) {
                const renderScene = new RenderPassClass(scene, camera);
                const bloomPass = new UnrealBloomPassClass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, 0.4, 0.85
                );
                bloomPass.strength = 2.0;
                bloomPass.radius = 0.6;
                bloomPass.threshold = 0.1;

                composer = new EffectComposerClass(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            }
        } catch (error) {
            console.warn('后处理效果初始化失败:', error);
            composer = null;
        }
    }

    /**
     * 初始化 MediaPipe
     */
    function initMediaPipe() {
        if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
            console.warn('MediaPipe 未加载，跳过摄像头初始化');
            document.getElementById('loading').classList.add('hidden');
            return;
        }
        
        videoElement = document.getElementById('video-input');
        
        try {
            const HandsClass = window.Hands || Hands;
            const CameraClass = window.Camera || Camera;
            
            const hands = new HandsClass({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new CameraClass(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            const startResult = cameraUtils.start();
            if (startResult && typeof startResult.catch === 'function') {
                startResult.catch((error) => {
                    console.error('摄像头启动失败:', error);
                    document.getElementById('loading').classList.add('hidden');
                });
            }
        } catch (error) {
            console.error('MediaPipe 初始化错误:', error);
            document.getElementById('loading').classList.add('hidden');
        }
    }

    /**
     * 手势识别结果处理
     */
    function onHandsResults(results) {
        document.getElementById('loading').classList.add('hidden');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            handLandmarks = landmarks;

            // 检测手势：握拳 vs 张开
            const fingerTips = [8, 12, 16, 20];
            const fingerMCPs = [5, 9, 13, 17];
            let extendedFingers = 0;

            for (let i = 0; i < 4; i++) {
                const tip = landmarks[fingerTips[i]];
                const mcp = landmarks[fingerMCPs[i]];
                const wrist = landmarks[0];
                
                const distTipWrist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                const distMcpWrist = Math.hypot(mcp.x - wrist.x, mcp.y - wrist.y);

                if (distTipWrist > distMcpWrist * 1.2) {
                    extendedFingers++;
                }
            }

            // 状态切换
            if (extendedFingers >= 3) {
                targetState = 'open';
                updateStatus('散开态');
            } else if (extendedFingers <= 1) {
                targetState = 'closed';
                updateStatus('合拢态');
            }

            // 相机控制（仅在散开态）
            if (targetState === 'open' && currentStateRatio > 0.5) {
                const palmX = landmarks[9].x;
                const palmY = landmarks[9].y;
                
                // 计算手部旋转角度
                const indexFinger = landmarks[8];
                const middleFinger = landmarks[12];
                const handCenterX = (indexFinger.x + middleFinger.x) / 2;
                const handCenterY = (indexFinger.y + middleFinger.y) / 2;
                
                // 映射到相机角度
                cameraRotationY = (palmX - 0.5) * 2;
                cameraRotationX = (palmY - 0.5) * 2;
            } else {
                cameraRotationX = 0;
                cameraRotationY = 0;
            }
        } else {
            handLandmarks = null;
        }
    }

    /**
     * 更新状态显示
     */
    function updateStatus(text) {
        const statusEl = document.getElementById('status');
        if (statusEl) {
            statusEl.textContent = '状态: ' + text;
        }
    }

    /**
     * 窗口大小调整
     */
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (composer) {
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    /**
     * 动画循环
     */
    function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() * 0.001;

        // 状态切换平滑过渡
        if (targetState === 'closed') {
            currentStateRatio = Math.max(0, currentStateRatio - CONFIG.transitionSpeed);
        } else if (targetState === 'open') {
            currentStateRatio = Math.min(1, currentStateRatio + CONFIG.transitionSpeed);
        }

        // 更新粒子位置
        particleData.forEach((data, index) => {
            const targetPos = data.mesh.position.clone().lerp(
                currentStateRatio > 0.5 ? data.chaosPos : data.treePos,
                currentStateRatio
            );
            
            // 添加漂浮动画
            if (currentStateRatio > 0.5) {
                const floatAmount = currentStateRatio * 2;
                targetPos.x += Math.sin(time * 0.5 + index) * floatAmount;
                targetPos.y += Math.cos(time * 0.7 + index) * floatAmount;
                targetPos.z += Math.sin(time * 0.6 + index) * floatAmount;
            }
            
            data.mesh.position.lerp(targetPos, 0.1);
            
            // 旋转动画
            if (data.type === 'box' || data.type === 'candy') {
                data.mesh.rotation.x += 0.01;
                data.mesh.rotation.y += 0.01;
            }
            
            // 照片朝向相机
            if (data.type === 'photo') {
                data.mesh.lookAt(camera.position);
            }
        });

        // 相机控制
        if (currentStateRatio > 0.5) {
            const targetX = Math.sin(cameraRotationY) * 60;
            const targetY = 20 + Math.cos(cameraRotationX) * 30;
            const targetZ = 80 + Math.cos(cameraRotationY) * 20;
            
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            camera.position.z += (targetZ - camera.position.z) * 0.05;
            camera.lookAt(0, 0, 0);
        } else {
            camera.position.x += (0 - camera.position.x) * 0.05;
            camera.position.y += (20 - camera.position.y) * 0.05;
            camera.position.z += (80 - camera.position.z) * 0.05;
            camera.lookAt(0, 0, 0);
        }

        // 整体旋转
        particlesGroup.rotation.y = time * 0.05;

        // 渲染
        if (composer) {
            composer.render();
        } else {
            renderer.render(scene, camera);
        }
    }

    /**
     * 主程序入口
     */
    let initializationStarted = false;
    let threeReady = false;
    let mediapipeReady = false;
    
    function checkAndInit() {
        if (initializationStarted) return;
        if (!threeReady) {
            console.log('等待 Three.js 加载...');
            return;
        }
        if (!mediapipeReady) {
            console.log('等待 MediaPipe 加载（可选）...');
            return;
        }
        
        initializationStarted = true;
        console.log('开始初始化场景...');
        try {
            init();
            initMediaPipe();
            animate();
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
        } catch (error) {
            console.error('初始化错误:', error);
            document.getElementById('loading').textContent = '初始化失败: ' + error.message;
        }
    }
    
    function checkThreeLoaded() {
        if (window.THREE && window.THREE.Scene) {
            threeReady = true;
            console.log('Three.js 已加载');
            checkAndInit();
            return true;
        }
        return false;
    }
    
    if (window.threeLoaded || checkThreeLoaded()) {
        threeReady = true;
        checkAndInit();
    } else {
        window.onThreeLoaded = () => {
            threeReady = true;
            console.log('Three.js 加载完成（通过回调）');
            checkAndInit();
        };
        
        const checkThree = setInterval(() => {
            if (checkThreeLoaded()) {
                clearInterval(checkThree);
            }
        }, 100);
        
        setTimeout(() => {
            clearInterval(checkThree);
            if (!threeReady && window.THREE) {
                threeReady = true;
                checkAndInit();
            }
        }, 10000);
    }
    
    function checkMediaPipeLoaded() {
        if ((typeof Hands !== 'undefined' && typeof Camera !== 'undefined') ||
            (window.Hands && window.Camera)) {
            mediapipeReady = true;
            console.log('MediaPipe 已加载');
            checkAndInit();
            return true;
        }
        return false;
    }
    
    if (checkMediaPipeLoaded()) {
    } else {
        const checkMediaPipe = setInterval(() => {
            if (checkMediaPipeLoaded()) {
                clearInterval(checkMediaPipe);
            }
        }, 100);
        
        setTimeout(() => {
            clearInterval(checkMediaPipe);
            if (!mediapipeReady) {
                console.warn('MediaPipe 加载超时，继续初始化（无摄像头功能）');
                mediapipeReady = true;
                checkAndInit();
            }
        }, 2000);
    }
</script>
</body>
</html>

